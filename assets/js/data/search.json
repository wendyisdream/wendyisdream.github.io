[ { "title": "sed 사용 예", "url": "/posts/sed/", "categories": "Blogging, 개발환경", "tags": "개발환경", "date": "2022-09-15 00:00:00 +0900", "snippet": "sed란man sed에서 알려주는 sed란?sed - stream editor for filtering and transforming text 이번에 html/javascript 파일 전체를 C에서 string로 인식하기 위해변환이 필요한 부분에 sed를 사용해서 한번에! 변경시 사용한 내용을 적어보자!옵션 i 옵션 : 파일에 직접 수정할 때 사용한다.이 옵션 사용전에 먼저 standard output으로 정상적으로 동작 확인 후 사용했다. -i[SUFFIX], --in-place[=SUFFIX] edit files in place (makes backup if SUFFIX supplied) backup 파일 만들때 suffix도 사용할 수 있어 좋다. C에서 특수 문자를 character로 사용하기 위한 escape character 추가 대상 파일에 포함된 escape chactacter가 필요한 문자는 “, ‘, \\, 가 있었다.이것에 escape chacter를 추가하기 위해서 다음을 실행하였다. sed -i.org 's/\\\\/\\\\\\\\/g' mermaid.js ( \\ -&gt; \\\\로 변경 )sed -i.org 's/\\\"/\\\\\"/g' mermaid.js ( \" -&gt; \\\" 로 변경 )sed -i.org \"s/'/\\\\\\'/g\" mermaid.js ( ' -&gt; \\' 로 변경 ) 라인의 마지막에 특정 문자 추가 줄바꿈에서는 \\n를 추가해야하며, 다음 줄과의 연결을 위해서는 \\을 추가가 필요했다. 즉 라인의 마지막에 \\n\\ 추가하기! 이다. sed에서 라인의 마지막을 나타내는 것은 $, 라인의 처음을 나타내는 것은 ^ 이다. 따라서 다음과 같이 변경한다. sed -i.org 's/$/\\\\n\\\\/g' mermaid.html 이때 \\가 문자로 인식하기 위해서는 \\를 한번 더 써줘야한다 \\ /g 옵션은 문서 전체에 적용되게 한다.다수의 변경 적용-e 옵션을 사용시 ; 를 구분자로 하여 다수의 변환을 할수 있다.#### c 에서 스트링 변환을 위한 방법 string literal concatenation sed -e 's/\\\\/\\\\\\\\/g;s/\\\"/\\\\\"/g;s/$/\\\\n\\\"/;s/^/\\\"/' (target file) add the backslash at the end of the line and add “ for the first and last onlysed -e 's/\\/\\\\/g;s/\"/\\\"/g;s/$/\\n\\/;1s/^/\"/;$ a \"' (target file)" }, { "title": "uftrace record data unit", "url": "/posts/uftrace_data_unit/", "categories": "Blogging, Uftrace", "tags": "study", "date": "2022-08-13 00:00:00 +0900", "snippet": "타켓 프로그램의 실행 과정 중 uftrace libmcount.so는 함수의 entry/exit, event 발생 시 정보를 hook하고 uftrace는 데이터를 {tid}.dat에 기록한다.argument/return value나 file name/line number등의 추가 debug 정보가 요청되면 .dbg에 관련 정보가 저장된다.Test code를 대상으로 uftrace가 저장하는 모습을 살펴보자~ Test code #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int fib(int n) { if (n &lt;= 2) return 1; return fib(n - 1) + fib(n - 2); } int main(int argc, char *argv[]) { int n = 8; if (argc &gt; 1) n = atoi(argv[1]); fib(n); return 0; } 컴파일gcc -pg -g tests/s-fibonacci.c로 컴파일 후에 uftrace에 argument/return value를 저장하는 옵션으로 record를 해보자~ uftrace recorduftrace record -a a.out 3 uftrace replay로 실행과정을 확인해보자~ uftrace replay -a # DURATION TID FUNCTION 0.354 us [ 30729] | __monstartup(); 0.199 us [ 30729] | __cxa_atexit(); [ 30729] | main(2, 0x7fff586c0b08) {52.400 us [ 30729] | atoi(\"3\") = 3; [ 30729] | fib(3) { 0.094 us [ 30729] | fib(2) = 1; 0.055 us [ 30729] | fib(1) = 1; 0.743 us [ 30729] | } = 2; /* fib */54.631 us [ 30729] | } = 0; /* main */ 위의 결과를 위한 uftrace에서 저장한 데이터의 단위와 포멧을 확인해보자.uftrace.data의 {tid}.dat을 보면 다음과 같다.각 entry/exit에서 저장되는 단위는 다음과 같이 16byte 정보가 기본이 된다.struct uftrace_record {\tuint64_t time;\tuint64_t type : 2;\tuint64_t more : 1;\tuint64_t magic : 3;\tuint64_t depth : 10;\tuint64_t addr : 48; /* child ip or uftrace_event_id */};__monstartup와 같이 argument/return value등 추가 저장이 없는 경우(more==0)에는 16byte로 저장되고,fib와 같이 argument/return value가 있는 경우(more==1)에는 16byte에 argument(entry), return value(exit)값이 이어서 저장된다.각 함수의 argument/return value의 형식은 .dbg에 저장된다.s-fibonacci.c의 a.out 실행파일에 .dbg 내용은 다음과 같다. a.out.dbg # path name: /home/jia/workspace/uftrace/a.out# build-id: 3765f5db162cc251641fd169960c21ca15d2a197F: 77a fibL: 4 tests/s-fibonacci.cA: @arg1R: @retvalF: 7be mainL: 11 tests/s-fibonacci.cA: @arg1,arg2/pR: @retval " }, { "title": "clang asan으로 빌드 후 실행 시 applying zero offset to null pointer 에러 발생건", "url": "/posts/issue_invalidnullpointerhandling/", "categories": "Blogging, Uftrace", "tags": "study", "date": "2022-07-30 00:00:00 +0900", "snippet": "이슈 내용clang으로 ASAN=1 unittest 빌드 후 실행 시 runtime error: applying zero offset to null pointer 에러 발생/uftrace/utils/dwarf.c:2412:16: runtime error: applying zero offset to null pointerSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior uftrace에서 ASAN=1로 빌드시 적용되는 flagMakefile ifeq ($(ASAN), 1) ASAN_CFLAGS := -O0 -g -fsanitize=address,leak,undefined UFTRACE_CFLAGS += $(ASAN_CFLAGS)...endifcflag에 -O0 -g -fsanitize=address,leak,undefined가 추가된다. UBSANclang에서 UndefinedBehaviorSanitizer에서 체크하는 항목은 다음의 페이지에서 확인할수 있다.https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#ubsan-checks위의 검출이 해당되는 항목은 다음과 같다.-fsanitize=pointer-overflow: Performing pointer arithmetic which overflows, or where either the old or new pointer value is a null pointer (or in C, when they both are).원인이슈가 발생한 부분은 rb tree의 node를 따라가는데, 마지막 노드는 null이 되고, 이 값은 rb_entry의 첫번째 argument에 전달된다. rb_entry는 container_of로 재정의된다. container_of 란?container_of(ptr, type, member)ptr – the pointer to the member.type – the type of container struct this is embedded in.member – the name of the member within the struct.It returns the address of the container structure of the member.아래의 페이지의 자세한 설명이 이해를 도와주었다!https://www.bhral.com/post/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90%EC%9D%98-container_of-%EB%A7%A4%ED%81%AC%EB%A1%9Ccontainer_of의 구현은#define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );})와 같음으로 ptr이 null로 전달되는 경우 null에 대한 offsetof(type,member) (여기서는 0) 의 뺄셈이 되어 ubsan에 의해서applying zero offset to null pointer 를 발생시켰다.수정rb tree의 마지막 모드이면 tree traversal를 중지하고 빠져나올 수 있도록 null 체크를 추가하였다.rb_entry에 null을 전달하지 않도록..https://github.com/namhyung/uftrace/pull/1494참고1) rb tree란https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC" }, { "title": "github blog", "url": "/posts/github_blog/", "categories": "Blogging, 개발환경", "tags": "개발환경", "date": "2022-07-28 00:00:00 +0900", "snippet": "GitHub 에 블로그 만들기 - jekyll 이용개발 블로그 플랫폼을 찾아보다가, GitHub 를 이용할수 있다는 것을 알게 되어 적용해 보았다. 바로 이곳!:)GitHub 블로그는 jekyll 을 사용하여 사이트를 생성한다고 한다.Jekyll 이란?https://en.wikipedia.org/wiki/Jekyll_(software)jekyll을 로컬 개발 서버에서 실행하여 확인해볼때 사용법은 공식 사이트와 테마의 가이드 문서가 가장 정확했다. (영어 독해가 바로 안됬을 뿐…)jekyll themesjekyll 테마를 제공하는 여러 사이트가 있다.맘에 드는 테마를 골라 사용! https://jamstackthemes.dev https://jekyllthemes.io https://jekyll-themes.com선택한 테마를 내 repository로 복사하기.github 블로그는 github repository로 관리된다.테마의 github에서 fork해서 가져오는 방법과 파일을 복사해서 가져오는 방법이 있다.테마의 공식 repository를 수정할게 아니라면 복사하는 방법이 더 좋을 것 같다.로컬 확인을 위한 환경 갖추기서버에 올리기전 로컬에 jekyll 환경을 갖춰서 확인해볼 수 있다. 설치 하자. sudo apt install ruby-bundlersudo apt install ruby-full build-essential zlib1g-devsudo apt install bundlersudo gem install jekyll blog 소스가 위치한 곳에서 실행 (1회 실행)bundle installbundle add jekyll 서비스 실행bundle exec jekyll s로컬에서 확인다음의 주소로 확인해 볼 수 있다.http://127.0.0.1:4000설정, style등 나의 정보로 업데이트하기기본 설정 정보는 _config.yml 에 있다. 각 테마에서 제공하는 가이드에 따라 설정을 진행하면 된다.GitHub 블로그의 페이지는 Github의 다른 문서와 마찬가지로 markdown 언어로 작성하면 된다." }, { "title": "frequently used git commands", "url": "/posts/frequently_used_gitcommand/", "categories": "Blogging, 개발환경", "tags": "개발환경", "date": "2022-07-28 00:00:00 +0900", "snippet": "자주 사용하는 git command 모음git 이 익숙치 않아 사용할때 마다 정보를 찾곤 한다. 사용하게 되는 git command를 적어 보자작업 준비 현재 소스 상태 확인git status 현재 branch 확인git branch branch 생성git checkout -b {branch name} branch 삭제git branch -D {branch name} fork 한 것에서 clone하여 가져온 repo인경우 fork를 생성한 원 repository를 remote에 upstream으로 등록해줘야한다.git remote add upstream {fork가 생성된 원 repository} remote 정보 확인git remote -v코드 stage -&gt; commit -&gt; PR한개의 반영 단위를 commit 인데, 반영에 포함될 파일을 먼저 staged 상태로 만든 후 commit하면 된다. 파일을 staging 상태로 만들기git add {file} staging area의 파일을 commit하기git commit -sm {commit message}이떄 -m 옵션은 메시지, -s 옵션은 singed-off 정보(git config의 정보)가 commit message 끝에 함게 기입된다. 원격서버에 반영하기orgin은 git clone으로 가져온 repository이며, upstream은 fork가 수행된 원 repository이다. 원 소스와 싱크를 맞추기git fetch는 target branch로 부터 commit history를 가져온다. 이때 로컬 코드에 대한 수정이 이루어지진 않는다.git fetch upstream master fetch로 가져온 최신을 현재 로컬에 반영git rebase upstream/master remote에 코드 올리기git push origin {branch} github 사이트에서 업데이트된 commit에 대해 원 repo로 pull request를 보내면 됨! 작업 중 수정이 필요할 때 commit 메시지 수정하기git command --amend staging area 에 있는 파일을 다시 unstage로 변경git reset HEAD {file} commit을 취소 하고 싶을때 commit을 취소 &amp; 파일을 staged 상태로 두기git reset --soft HEAD^ commit을 취소 &amp; 파일을 unstaged 상태로 두기 git reset --mixed HEAD^ 이미 PR한 commit 내용 수정하기commit 메시지 변경시 git log로 현재 수정할 commit 위치 확인git log 해당 커밋을 commit 메시지 수정 모드로 변경git rebase -i HEAD~{수정할 commit의 위치번호} –&gt; pick을 reword로 변경하고 저장하면 변경하는 화면 나옴 $git rebase -i HEAD~{수정할 commit의 순서} pick a5c3307f tests: Fix applying zero offset to null pointer in unittest # Rebase 07332935..a5c3307f onto 07332935 1 command # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # d, drop = remove commit 수정 후 pushgit push -f origin {branch-name} code 변경시 git log로 현재 수정할 commit 위치 확인git log 해당 커밋을 내용 수정 모드로 변경git rebase -i HEAD~{수정할 commit의 위치번호} –&gt; pick을 edit로 변경하고 저장 $ git rebase -i HEAD~{수정할 commit의 순서} pick a5c3307f tests: Fix applying zero offset to null pointer in unittest # Rebase 07332935..a5c3307f onto 07332935 (1 command) # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # d, drop = remove commit # Stopped at c01b6eb9... tests: Fix applying zero offset to null pointer in unittest You can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue 로컬에서 변경 진행하고 해당 파일을 git add 후 commit –amend 하기 git add {변경파일} git commit --amend commit 작업이 완료되었음을 알림 git rebase --continue 코드를 원격 git 서버로 푸시~~ git push -f origin {branch-name} 참고 링크https://velog.io/@ongddree/git-%EC%9D%B4%EB%AF%B8-push%ED%95%9C-commit-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0https://backlog.com/git-tutorial/kr/stepup/stepup7_6.html" }, { "title": "uftrace를 사용한 분석 - vlc player", "url": "/posts/uftrace_vlc_player/", "categories": "Blogging, Uftrace", "tags": "study", "date": "2022-07-23 00:00:00 +0900", "snippet": "VLC 빌드소스 가져오기git clone https://github.com/videolan/vlc.git필요 패키지 설치WSL2 환경에서 다수의 패키지의 설치가 필요했다.bootstrap과 configure 단계에서 에러 발생시 다음의 사이트에서 검색해서 찾을 수 있었다.ubuntu 패키지 찾기 https://packages.ubuntu.com/search?keywords=xcb&amp;searchon=names&amp;suite=jammy&amp;section=all./bootstrap 단계에서 설치한 패키지sudo apt install flex bison autopoint gettext libtool autoconf./configure 단계에서 설치한 패키지 (–disable-qt 옵션 사용)sudo apt install lua5.2 liblua5.2-dev libavcodec-dev libavutil-dev libavformat-dev libswscale-devsudo apt install liba52-dev libxcb-composite0-dev libalsa-ocaml-devsudo apt install libxcb-randr0-dev libxcb-shm0-dev libxcb-xkb-devvlc player 빌드vlc player에 pg 옵션을 넣어 빌드!./bootstrap./configure --disable-qt CFLAGS=\"-pg\"./make UFTRACE를 이용한 VLC 분석graphtask\t$ uftrace graph --task\t========== TASK GRAPH ==========\t# TOTAL TIME SELF TIME TID TASK NAME\t\t1.043 m 82.056 ms [ 19833] : vlc\t\t1.043 m 22.826 us [ 19836] : +-vlc-exec-runner\t\t1.043 m 1.589 ms [ 19837] : +-vlc-exec-runner\t\t1.043 m 29.841 us [ 19839] : +-vlc-exec-runner\t\t1.043 m 3.003 ms [ 19838] : +-vlc-exec-runner\t\t1.043 m 18.807 us [ 19840] : +-vlc-exec-runner\t\t1.043 m 546.857 us [ 19841] : +-vlc-player-end\t 33.906 ms 22.701 ms [ 19842] : +-vlc-preparse\t\t1.043 m 348.612 us [ 19843] : +-vlc-cli-client\t\t1.021 m 387.175 ms [ 19844] : +-vlc-input\t\t1.021 m 383.284 ms [ 19851] : +-vlc-dec-video\t\t1.021 m 580.095 ms [ 19852] : +-vlc-dec-audio\t\t1.019 m 1.006 m [ 19845] : +-vlc-static\t\t1.043 m 61.519 ms [ 19854] : +-vlc-spu-prerend\t\t1.043 m 1.055 ms [ 19855] : +-vlc-window-x11\t\t1.043 m 408.717 us [ 19856] : +-vlc-timer\t\t1.020 m 3.686 s [ 19873] : +-vlc-vout\t\t1.019 m 1.006 m [ 19846] : +-vlc-static\t\t1.019 m 1.006 m [ 19847] : +-vlc-static\t\t1.019 m 1.006 m [ 19848] : +-vlc-static\t\t1.019 m 1.006 m [ 19849] : +-vlc-static\t\t1.019 m 1.006 m [ 19850] : +-vlc-staticreplay vlc-dec-video위의 task 중 vlc-dec-video thread를 조금 더 알고 싶다.그런데 결과에 mutex가 너무 많아~서 mutex 는 제외하고 확인해본다. $ uftrace replay --tid=19851 -N vlc_mutex* -T 'DecoderThread_ProcessInput@filter,backtrace,depth=5' # DURATION TID FUNCTION backtrace [ 19851] | /* [ 0] DecoderThread */ [ 19851] | DecoderThread_ProcessInput() { 0.055 us [ 19851] | DecoderUpdatePreroll(); [ 19851] | DecoderThread_DecodeBlock() { [ 19851] | vlc_object_get_tracer() { [ 19851] | vlc_object_instance() { 0.139 us [ 19851] | vlc_object_parent(); 0.221 us [ 19851] | vlc_object_parent(); 0.152 us [ 19851] | vlc_object_parent(); 0.083 us [ 19851] | vlc_object_parent(); 0.979 us [ 19851] | } /* vlc_object_instance */ 0.034 us [ 19851] | libvlc_priv(); 1.177 us [ 19851] | } /* vlc_object_get_tracer */ [ 19851] | DecodeVideo() { [ 19851] | DecodeBlock() { 0.056 us [ 19851] | filter_earlydropped_blocks(); 0.534 us [ 19851] | vlc_frame_Realloc(); 1.238 us [ 19851] | vlc_frame_Release(); 96.708 us [ 19851] | } /* DecodeBlock */ 96.932 us [ 19851] | } /* DecodeVideo */ 98.796 us [ 19851] | } /* DecoderThread_DecodeBlock */ 99.964 us [ 19851] | } /* DecoderThread_ProcessInput */ backtrace [ 19851] | /* [ 0] DecoderThread */ [ 19851] | DecoderThread_ProcessInput() { 0.104 us [ 19851] | DecoderUpdatePreroll(); vlc-input $ uftrace replay --tid=19844 -N vlc_mutex* # DURATION TID FUNCTION [ 19844] | Run() { [ 19844] | vlc_thread_set_name() { [ 19844] | /* linux:task-name (comm=\"vlc-input\") */ 1.757 us [ 19844] | } /* vlc_thread_set_name */ 0.103 us [ 19844] | vlc_interrupt_set(); [ 19844] | Init() { 0.056 us [ 19844] | input_priv(); [ 19844] | input_ChangeState() { 0.046 us [ 19844] | input_priv(); 0.040 us [ 19844] | input_priv(); [ 19844] | input_SendEventState() { [ 19844] | input_SendEvent() { 0.056 us [ 19844] | input_priv(); [ 19844] | input_thread_Events() { [ 19844] | vlc_player_input_HandleStateEvent() { [ 19844] | vlc_player_input_HandleState() { 0.068 us [ 19844] | vlc_list_it_start(); 0.041 us [ 19844] | vlc_list_it_continue(); 0.061 us [ 19844] | vlc_list_it_next(); 0.041 us [ 19844] | vlc_list_it_continue(); 0.055 us [ 19844] | vlc_list_it_next(); 0.049 us [ 19844] | vlc_list_it_continue(); [ 19844] | player_on_state_changed() { [ 19844] | msg_print() { [ 19844] | msg_vprint() { 0.040 us [ 19844] | vlc_list_it_start(); 0.046 us [ 19844] | vlc_list_it_continue(); [ 19844] | cli_vprintf() { [ 19844] | cli_writev() { 16.744 us [ 19844] | vlc_writev(); 20.204 us [ 19844] | } /* cli_writev */ 21.418 us [ 19844] | } /* cli_vprintf */ 0.064 us [ 19844] | vlc_list_it_next(); 0.037 us [ 19844] | vlc_list_it_continue(); 27.447 us [ 19844] | } /* msg_vprint */ 27.586 us [ 19844] | } /* msg_print */ 27.741 us [ 19844] | } /* player_on_state_changed */ report 가장 많이 불린 함수는? $ uftrace report -f all -s call Total time Total avg Total min Total max Self time Self avg Self min Self max Calls Function ========== ========== ========== ========== ========== ========== ========== ========== ========== ==================== 74.468 ms 0.123 us 0.025 us 62.331 us 74.468 ms 0.123 us 0.025 us 62.331 us 604988 vlc_thread_id 189.923 ms 0.458 us 0.103 us 226.244 us 131.843 ms 0.318 us 0.074 us 130.732 us 414036 vlc_mutex_held 196.476 ms 1.031 us 0.220 us 227.229 us 75.129 ms 0.394 us 0.094 us 128.730 us 190424 vlc_mutex_trylock 131.035 ms 0.688 us 0.168 us 177.329 us 40.653 ms 0.213 us 0.062 us 176.732 us 190424 vlc_mutex_unlock 681.213 ms 3.613 us 0.308 us 212.013 ms 37.608 ms 0.199 us 0.059 us 129.470 us 188501 vlc_mutex_lock 14.842 ms 0.141 us 0.026 us 73.956 us 14.842 ms 0.141 us 0.026 us 73.956 us 105224 fourcc_cmp 11.186 ms 0.155 us 0.024 us 104.158 us 11.186 ms 0.155 us 0.024 us 104.158 us 71910 vlc_object_parent 4.119 ms 0.061 us 0.024 us 34.994 us 4.119 ms 0.061 us 0.024 us 34.994 us 67420 MP4_rescale 17.242 ms 0.277 us 0.096 us 103.390 us 13.443 ms 0.216 us 0.070 us 103.279 us 62034 MP4_rescale_mtime 3.258 ms 0.067 us 0.024 us 29.562 us 3.258 ms 0.067 us 0.024 us 29.562 us 48173 vlc_tick_from_seci 18.935 ms 0.393 us 0.109 us 134.327 us 15.676 ms 0.325 us 0.082 us 134.204 us 48173 vlc_tick_now 3.466 ms 0.093 us 0.028 us 50.077 us 3.466 ms 0.093 us 0.028 us 50.077 us 36932 GCD 2.334 ms 0.068 us 0.024 us 21.851 us 2.334 ms 0.068 us 0.024 us 21.851 us 34194 input_priv 1.001 h 45.701 ms 1.354 us 1.043 m 1.001 h 45.701 ms 1.354 us 1.043 m 33619 linux:schedule 23.596 ms 0.839 us 0.299 us 104.639 us 8.053 ms 0.286 us 0.098 us 73.451 us 28124 MP4_TrackGetDTSPTS 9.644 ms 0.353 us 0.113 us 102.483 us 7.193 ms 0.263 us 0.081 us 102.312 us 27258 LCM 1.723 ms 0.063 us 0.024 us 12.770 us 1.723 ms 0.063 us 0.024 us 12.770 us 27051 vlc_fifo_queue 비교를 해보자~ $ uftrace report --diff uftrace.data.old -f total,total-min,self-avg --diff-policy full # # uftrace diff # [0] base: uftrace.data (from uftrace record --srcline ./vlc ./sunrise.mp4) # [1] diff: uftrace.data.old (from uftrace record ./vlc ./sunrise.mp4) # Total time (diff) Total min (diff) Self avg (diff) Function =================================== =================================== =================================== ==================== 15.030 m 2.022 h +2.006 h 42.994 s 4.008 m +3.025 m 58.142 s 4.023 m +3.024 m exit 1.001 h 2.021 h +1.020 h 1.354 us - -1.354 us 45.701 ms 94.813 ms +49.112 ms linux:schedule 18.051 m 1.022 h +1.003 h 0.388 us 0.382 us -0.006 us 2.025 us 1.726 us -0.299 us vlc_futex_wait 18.052 m 1.022 h +1.003 h 0.108 us 0.106 us -0.002 us 14.888 us 9.685 us -5.203 us sys_futex 15.005 m 1.018 h +1.003 h 56.737 us 18.658 us -38.079 us 1.136 us 0.748 us -0.388 us vlc_cond_wait 15.006 m 1.018 h +1.003 h 0.467 us 0.470 us +0.003 us 0.264 us 0.170 us -0.094 us vlc_atomic_wait 8.037 m 1.001 h +17.004 m 1.043 m 5.008 m +3.024 m 1.999 us 2.635 us +0.636 us ThreadRun 8.037 m 1.001 h +17.004 m 42.627 ms 43.002 ms +374.319 us 0.676 us 0.706 us +0.030 us QueueTake 1.043 m 5.008 m +3.024 m 1.043 m 5.008 m +3.024 m 10.128 ms 12.895 ms +2.767 ms cli_client_thread 1.043 m 5.008 m +3.024 m 1.043 m 5.008 m +3.024 m 10.606 us 6.500 us -4.106 us vlc_player_destructor_Thread 1.043 m 5.008 m +3.024 m 1.043 m 5.008 m +3.024 m 25.006 us 26.744 us +1.738 us sigwait 1.043 m 5.008 m +3.024 m 1.043 m 5.008 m +3.024 m 15.012 us 9.342 us -5.670 us main 1.043 m 5.008 m +3.024 m 1.043 m 5.008 m +3.024 m 2.025 ms 1.437 ms -588.921 us spu_PrerenderThread 1.043 m 5.008 m +3.024 m 1.043 m 5.008 m +3.024 m 26.145 us 10.792 us -15.353 us vlc_timer_thread 3.004 m 6.028 m +3.024 m 1.020 m 1.020 m -816.621 ms 5.141 ms 5.418 ms +277.303 us Thread 1.019 m 28.347 s -51.258 s 13.959 us 31.061 us +17.102 us 0.814 us 0.578 us -0.236 us DecoderThread_ProcessInput 1.019 m 28.337 s -51.254 s 13.561 us 30.176 us +16.615 us 0.610 us 0.427 us -0.183 us DecoderThread_DecodeBlock 1.019 m 28.328 s -51.250 s 10.271 us 29.443 us +19.172 us 59.192 us 41.302 us -17.890 us DecodeBlock 1.018 m 27.729 s -51.146 s 66.771 us 55.661 us -11.110 us 0.222 us 0.183 us -0.039 us DecodeVideo 1.020 m 2.011 m +50.527 s 57.159 us 19.057 us -38.102 us 0.337 us 0.263 us -0.074 us vlc_fifo_Wait 1.020 m 2.011 m +50.527 s 56.910 us 18.792 us -38.118 us 0.458 us 0.268 us -0.190 us vlc_queue_Wait 1.018 m 40.132 s -37.999 s 10.171 us 9.671 us -0.500 us 12.314 us 6.998 us -5.316 us lavc_dr_GetFrame 1.018 m 40.116 s -37.988 s 8.660 us 7.828 us -0.832 us 0.800 us 0.438 us -0.362 us decoder_NewPicture 1.018 m 40.115 s -37.987 s 8.528 us 7.708 us -0.820 us 1.539 us 1.026 us -0.513 us ModuleThread_NewVideoBuffer 1.018 m 40.112 s -37.986 s 7.870 us 7.104 us -0.766 us 1.653 us 1.104 us -0.549 us picture_pool_Wait 1.018 m 40.357 s -37.952 s 28.149 us 24.503 us -3.646 us 2.347 us 1.542 us -0.805 us lavc_GetFrame 12.402 s 7.447 s -4.955 s 3.275 ms 3.119 ms -156.284 us 204.669 us 136.946 us -67.723 us PictureRender 1.004 m 1.008 m +4.080 s 7.003 us 8.921 us +1.918 us 0.720 us 0.530 us -0.190 us vlc_clock_Wait 3.045 m 3.048 m +2.966 s 1.258 us 0.852 us -0.406 us 1.253 us 0.959 us -0.294 us vlc_atomic_timedwait 3.045 m 3.048 m +2.948 s 6.549 us 8.342 us +1.793 us 1.298 us 1.035 us -0.263 us vlc_cond_timedwait info Todo) 여기에서 FLAGS가 의미는?\t$ uftrace info --task\t# TIMESTAMP FLAGS TID TASK DATA SIZE\t\t\t165175.517868585 FS [ 19833] vlc 3.797 MB\t\t\t165175.565699180 [ 19836] vlc-exec-runner 0.001 MB\t\t\t165175.566791025 [ 19837] vlc-run-prepars 0.117 MB\t\t\t165175.566866697 [ 19838] vlc-exec-runner 0.038 MB\t\t\t165175.566988895 [ 19839] vlc-exec-runner 0.001 MB\t\t\t165175.567439094 [ 19840] vlc-exec-runner 0.001 MB\t\t\t165175.609405416 [ 19841] vlc-player-end 0.015 MB\t\t\t165175.611223100 [ 19842] vlc-preparse 1.320 MB\t\t\t165175.614638686 [ 19843] vlc-cli-client 0.001 MB\t\t\t165175.615249899 [ 19844] vlc-input 35.978 MB\t\t\t165175.661827535 [ 19845] vlc-static 2.447 MB\t\t\t165175.661912350 [ 19846] vlc-static 1.969 MB\t\t\t165175.661977935 [ 19847] vlc-static 1.970 MB\t\t\t165175.662046004 [ 19848] vlc-static 1.969 MB\t\t\t165175.662107140 [ 19849] vlc-static 1.966 MB\t\t\t165175.662166497 [ 19850] vlc-static 1.963 MB\t\t\t165175.662216979 [ 19851] vlc-dec-video 15.106 MB\t\t\t165175.681335551 [ 19852] vlc-dec-audio 25.087 MB\t\t\t165175.767731697 [ 19854] vlc-spu-prerend 2.486 MB\t\t\t165175.773089153 [ 19855] vlc-window-x11 0.023 MB\t\t\t165175.777119407 [ 19856] vlc-timer 0.006 MB\t\t\t165175.853211605 [ 19873] vlc-vout 28.484 MB\t\t\t165205.778313709 FS [ 19874] xdg-screensaver 0.553 MBlivedumprecvscript\t$ uftrace script -S ../../uftrace/scripts/simple.py\tprogram begins...\tentry : main()\tentry : signal()\texit : signal()\tentry : signal()\texit : signal()tui call graph에서 출력되는 session의 순서는 가장 동작이 많은 순서인가? G call Graph for session #1: vlc-static call Graph for session #2: dash call Graph for session #3: mv call Graph for session #4: grep call Graph for session #5: sed call Graph for session #6: dash TOTAL TIME : FUNCTION 1.001 h : (1) vlc-static 1.043 m : ├▶(1) main : │ 8.037 m : ├▶(5) ThreadRun : │ 1.043 m : ├▶(1) vlc_player_destructor_Thread : │ 33.906 ms : ├▶(1) Preparse : │ 1.043 m : ├▶(1) cli_client_thread : │ 1.021 m : ├▶(1) Run : │ 2.042 m : ├▶(2) DecoderThread : │ 94.506 ms : ├▶(1) ffmpeg_GetFormat : │ 1.043 m : ├▶(1) spu_PrerenderThread : │ 3.004 m : ├▶(2) Thread : │ 1.043 m : ├▶(1) vlc_timer_thread : │ 1.018 m : └▶(1923) lavc_GetFrame DecoderThread 열어보자~ TOTAL TIME : FUNCTION 2.042 m : ├─(2) DecoderThread 3.868 us : │ ├─(2) vlc_thread_set_name : │ │ 11.097 ms : │ ├▶(5374) vlc_fifo_Lock : │ │ 20.813 ms : │ ├▶(11400) vlc_cond_signal : │ │ 14.313 ms : │ ├▶(5700) vlc_fifo_DequeueUnlocked : │ │ 1.020 m : │ ├▶(328) vlc_fifo_Wait : │ │ 8.924 ms : │ ├▶(5374) vlc_fifo_Unlock : │ │ 1.019 m : │ ├─(5372) DecoderThread_ProcessInput 5.929 ms : │ │ ├▶(5370) vlc_mutex_lock : │ │ │ 611.426 us : │ │ ├─(5370) DecoderUpdatePreroll : │ │ │ 3.098 ms : │ │ ├▶(5370) vlc_mutex_unlock : │ │ │ 1.019 m : │ │ └─(5372) DecoderThread_DecodeBlock 8.398 ms : │ │ ├▶(5372) vlc_object_get_tracer : │ │ │ 704.837 ms : │ │ ├─(3448) DecodeAudio 704.002 ms : │ │ │▶(3448) DecodeBlock : │ │ │ 1.018 m : │ │ └─(1924) DecodeVideo 1.018 m : │ │ ▶(1924) DecodeBlock : │ │ 7.150 ms : │ ├▶(5372) vlc_mutex_lock : │ │ 6.795 ms : │ ├▶(5372) vlc_mutex_unlock : │ │ 914.324 us : │ ├▶(320) vlc_aout_stream_UpdateLatency : │ │ 1.959 s : │ └▶(1) vlc_aout_stream_Drain : │ 94.506 ms : ├▶(1) ffmpeg_GetFormat " }, { "title": "uftrace 코드 분석- function size field", "url": "/posts/code_analysis_function_size/", "categories": "Blogging, Uftrace", "tags": "study", "date": "2022-07-23 00:00:00 +0900", "snippet": "uftrace 코드 분석 및 size filed 추가uftrace에서 report/graph/tui 에서 사용되는 data structure 파악을 위해 doxygen의 data structure 결과에 uftrace에서 record 결과로부터 내부 data structure에 메모리를 할당하고 값을 업데이트하는 부분을 따라가보며 구조체 옆에 함수 이름을 표기해 보았다size 는 symbol에 대한 데이터를 업데이트 하는 load_module_symbol_file 함수에서 업데이트 한다.아래와 같이 addr로 sorting된 상태이기 때문에 이전 addr와의 차이를 size로 저장한다.load_module_symbol_file if (symtab-&gt;nr_sym &gt; 1 &amp;&amp; sym[-1].size == 0) sym[-1].size = sym-&gt;addr - sym[-1].addr; report/graph/tui에 size field 추가 출력을 위해 수정해 본 commithttps://github.com/namhyung/uftrace/commit/19b561a24709ef1b00acf8e27c94c770b226eb61다음은 uftrace에 function size filed에 대한 결과를 확인해본것이다.size 필드의 값의 실제와의 비교readelf의 결과 65: 00000000000007ba 42 FUNC GLOBAL DEFAULT 14 foo 70: 00000000000007e4 97 FUNC GLOBAL DEFAULT 14 main gdb disas의 결과 (gdb) disas main Dump of assembler code for function main: 0x00000000000007e4 &lt;+0&gt;: push %rbp 0x00000000000007e5 &lt;+1&gt;: mov %rsp,%rbp 0x00000000000007e8 &lt;+4&gt;: sub $0x20,%rsp 0x00000000000007ec &lt;+8&gt;: callq *0x2007f6(%rip) # 0x200fe8 0x00000000000007f2 &lt;+14&gt;: mov %edi,-0x14(%rbp) 0x00000000000007f5 &lt;+17&gt;: mov %rsi,-0x20(%rbp) 0x00000000000007f9 &lt;+21&gt;: mov -0x20(%rbp),%rax 0x00000000000007fd &lt;+25&gt;: add $0x8,%rax 0x0000000000000801 &lt;+29&gt;: mov (%rax),%rax 0x0000000000000804 &lt;+32&gt;: test %rax,%rax 0x0000000000000807 &lt;+35&gt;: je 0x83e &lt;main+90&gt; 0x0000000000000809 &lt;+37&gt;: mov -0x20(%rbp),%rax 0x000000000000080d &lt;+41&gt;: add $0x8,%rax 0x0000000000000811 &lt;+45&gt;: mov (%rax),%rax 0x0000000000000814 &lt;+48&gt;: mov %rax,%rdi 0x0000000000000817 &lt;+51&gt;: callq 0x630 &lt;atoi@plt&gt; 0x000000000000081c &lt;+56&gt;: mov %eax,-0x4(%rbp) 0x000000000000081f &lt;+59&gt;: movl $0x0,-0x8(%rbp) 0x0000000000000826 &lt;+66&gt;: jmp 0x836 &lt;main+82&gt; 0x0000000000000828 &lt;+68&gt;: mov -0x8(%rbp),%eax 0x000000000000082b &lt;+71&gt;: mov %eax,%edi 0x000000000000082d &lt;+73&gt;: callq 0x7ba &lt;foo&gt; 0x0000000000000832 &lt;+78&gt;: addl $0x1,-0x8(%rbp) 0x0000000000000836 &lt;+82&gt;: mov -0x8(%rbp),%eax 0x0000000000000839 &lt;+85&gt;: cmp -0x4(%rbp),%eax 0x000000000000083c &lt;+88&gt;: jl 0x828 &lt;main+68&gt; 0x000000000000083e &lt;+90&gt;: mov $0x0,%eax 0x0000000000000843 &lt;+95&gt;: leaveq 0x0000000000000844 &lt;+96&gt;: retq End of assembler dump. uftrace의 symbol size 값 $ uftrace report -f +size Total time Self time Calls Size Function ========== ========== ========== ========== ==================== 8.408 us 1.545 us 1 108 main 6.161 us 1.487 us 3 42 foo 4.674 us 4.674 us 3 16 printf 0.894 us 0.894 us 1 16 __monstartup 0.702 us 0.702 us 1 16 atoi 0.393 us 0.393 us 1 16 __cxa_atexit =&gt; 이값은 test.sym에서의 0x850-0x7e4의 값 00000000000007e4 T main 0000000000000850 T __libc_csu_init uftrace에서는 main의 size가 dummy 공간까지 포함해서 더 큰데,라이브러리 함수의 시작은 16byte align을 맞추기 때문인것으로 생각된다. (uftrace 빌드 옵션에 따라 실제 크기로 같게 맞출수도 있을까?)size 값 확인 해보기uftrace자체의 size 확인 큰 순서대로.. $ uftrace report -f +size -s size Total time Self time Calls Size Function ========== ========== ========== ========== ==================== 379.341 us 375.811 us 2 5488 parse_option 654.927 ms 23.988 ms 29 4304 load_module_symtab 761.607 ms 55.653 us 1 4288 command_replay 20.763 us 15.750 us 5 4176 get_argspec_string 104.865 ms 61.194 ms 31640 2704 dd_type 180.175 us 22.025 us 3 2672 read_record_mmap 37.556 ms 3.028 ms 15 2560 load_elf_dynsymtab 444.593 us 49.785 us 13 2400 __read_rstack 10.091 us 10.091 us 8 2384 __fstack_consume 263.935 ms 44.834 us 1 2224 command_record 106.072 ms 102.200 us 1 2208 finish_writers 262.807 ms 46.116 us 1 2160 do_main_loop 251.592 ms 15.213 ms 6856 1920 dd_encoding gcc 최적화 옵션에 따른 차이[0] X [1] O3 $ uftrace report -f +size --diff=uftrace.data.old Total time Self time Calls Size Function =========== =========== =========== =========== ==================== -3.729 us -0.667 us -3 -42 foo -3.062 us -3.062 us -3 -16 printf -2.028 us +0.067 us +0 +4 main +1.957 us +1.957 us +3 +16 __printf_chk -0.654 us -0.654 us -1 -16 atoi +0.331 us +0.331 us +1 +16 strtol -0.197 us -0.197 us +0 +0 __monstartup -0.183 us -0.183 us +0 +0 __cxa_atexit 참고 function에 isra가 붙는데 이것의 의미는?https://stackoverflow.com/questions/13963150/what-does-the-gcc-function-suffix-isra-mean#:~:text=ISRA%20is%20the%20name%20of,created%20by%20IPA%20SRA%20...&amp;text=Perform%20interprocedural%20scalar%20replacement%20of,by%20parameters%20passed%20by%20value. doxygen 사용법https://onecellboy.tistory.com/342 stderr 출력을 파일로 저장하기 $ uftrace report -vv 2&gt;&amp;1 | tee -a &gt; report_vv.txt Todo session task dlop의 구분하는 과정vlc player의 task.txt의 결과 SESS timestamp=165175.535895084 pid=19833 sid=a8bc3745995b1ee5 exename=\"/home/jia/workspace/target_program/vlc/bin/vlc-static\" TASK timestamp=165175.535981731 tid=19833 pid=19833 DLOP timestamp=165175.564566883 tid=19833 sid=a8bc3745995b1ee5 base=7f50f5067000 libname=\"/home/jia/workspace/target_program/vlc/modules/.libs/libsyslog_plugin.so\" DLOP timestamp=165175.564805657 tid=19833 sid=a8bc3745995b1ee5 base=7f50f5067000 libname=\"/home/jia/workspace/target_program/vlc/modules/.libs/libsyslog_plugin.so\" ... TASK timestamp=165175.565860565 tid=19836 pid=19833 TASK timestamp=165175.566957031 tid=19837 pid=19833 ... DLOP timestamp=165175.567895904 tid=19833 sid=a8bc3745995b1ee5 base=7f50f42f0000 libname=\"/home/jia/workspace/target_program/vlc/modules/.libs/libalsa_plugin.so\" DLOP timestamp=165175.567895904 tid=19833 sid=a8bc3745995b1ee5 base=7f50dfcf9000 libname=\"/usr/lib/x86_64-linux-gnu/libasound.so.2\"" } ]
